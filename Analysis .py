# -*- coding: utf-8 -*-
"""Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wH6blOndgUUOWr2GxSxexgzV0Os3wRAh

## Define statistical metrics for wind speed and direction at different stations to evalute the performace of the different models
## Apply them on icon_d2, icon_eu, era5
"""

import xarray as xr
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error
import seaborn as sns

wind_data = xr.open_dataset("wind_2023.nc")


# Function to evaluate models
def evaluate_model(y_true, y_pred):
    mask = ~np.isnan(y_true) & ~np.isnan(y_pred)
    y_true = y_true[mask]
    y_pred = y_pred[mask]

    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    correlation = np.corrcoef(y_true, y_pred)[0, 1]
    return mae, rmse, correlation

# Open the dataset
wind_data = xr.open_dataset("wind_2023.nc")

# Initialize lists to store metrics for each station
mae_per_station_speed = []
rmse_per_station_speed = []
corr_per_station_speed = []

mae_per_station_direction = []
rmse_per_station_direction = []
corr_per_station_direction = []

# Iterate over each station
station_ids = np.unique(wind_data['station_id'].values)

for station_id in station_ids:
    # Filter data for the current station
    station_data = wind_data.sel(station_id=station_id)

    # Wind Speed Evaluation
    y_true_speed = station_data['measured_wind_speed'].values
    y_pred_icon_d2_speed = station_data['icon_d2_wind_speed'].values
    y_pred_icon_eu_speed = station_data['icon_eu_wind_speed'].values
    y_pred_era5_speed = station_data['era5_wind_speed'].values

    mae_icon_d2_speed, rmse_icon_d2_speed, corr_icon_d2_speed = evaluate_model(y_true_speed, y_pred_icon_d2_speed)
    mae_icon_eu_speed, rmse_icon_eu_speed, corr_icon_eu_speed = evaluate_model(y_true_speed, y_pred_icon_eu_speed)
    mae_era5_speed, rmse_era5_speed, corr_era5_speed = evaluate_model(y_true_speed, y_pred_era5_speed)

    mae_per_station_speed.append({'Station': station_id, 'icon_d2': mae_icon_d2_speed, 'icon_eu': mae_icon_eu_speed, 'era5': mae_era5_speed})
    rmse_per_station_speed.append({'Station': station_id, 'icon_d2': rmse_icon_d2_speed, 'icon_eu': rmse_icon_eu_speed, 'era5': rmse_era5_speed})
    corr_per_station_speed.append({'Station': station_id, 'icon_d2': corr_icon_d2_speed, 'icon_eu': corr_icon_eu_speed, 'era5': corr_era5_speed})

    # Wind Direction Evaluation
    y_true_direction = station_data['measured_wind_direction'].values
    y_pred_icon_d2_direction = station_data['icon_d2_wind_direction'].values
    y_pred_icon_eu_direction = station_data['icon_eu_wind_direction'].values
    y_pred_era5_direction = station_data['era5_wind_direction'].values

    mae_icon_d2_direction, rmse_icon_d2_direction, corr_icon_d2_direction = evaluate_model(y_true_direction, y_pred_icon_d2_direction)
    mae_icon_eu_direction, rmse_icon_eu_direction, corr_icon_eu_direction = evaluate_model(y_true_direction, y_pred_icon_eu_direction)
    mae_era5_direction, rmse_era5_direction, corr_era5_direction = evaluate_model(y_true_direction, y_pred_era5_direction)

    mae_per_station_direction.append({'Station': station_id, 'icon_d2': mae_icon_d2_direction, 'icon_eu': mae_icon_eu_direction, 'era5': mae_era5_direction})
    rmse_per_station_direction.append({'Station': station_id, 'icon_d2': rmse_icon_d2_direction, 'icon_eu': rmse_icon_eu_direction, 'era5': rmse_era5_direction})
    corr_per_station_direction.append({'Station': station_id, 'icon_d2': corr_icon_d2_direction, 'icon_eu': corr_icon_eu_direction, 'era5': corr_era5_direction})

# Convert to DataFrames
mae_per_station_df_speed = pd.DataFrame(mae_per_station_speed).set_index('Station')
rmse_per_station_df_speed = pd.DataFrame(rmse_per_station_speed).set_index('Station')
corr_per_station_df_speed = pd.DataFrame(corr_per_station_speed).set_index('Station')

mae_per_station_df_direction = pd.DataFrame(mae_per_station_direction).set_index('Station')
rmse_per_station_df_direction = pd.DataFrame(rmse_per_station_direction).set_index('Station')
corr_per_station_df_direction = pd.DataFrame(corr_per_station_direction).set_index('Station')

# Plot MAE, RMSE, and Correlation for each station (Speed)
plt.figure(figsize=(18, 6))

plt.subplot(1, 3, 1)
mae_per_station_df_speed.plot(kind='bar', ax=plt.gca())
plt.title('MAE per Station (Speed)')

plt.subplot(1, 3, 2)
rmse_per_station_df_speed.plot(kind='bar', ax=plt.gca())
plt.title('RMSE per Station (Speed)')

plt.subplot(1, 3, 3)
corr_per_station_df_speed.plot(kind='bar', ax=plt.gca())
plt.title('Correlation per Station (Speed)')

plt.tight_layout()
plt.show()

# Plot MAE, RMSE, and Correlation for each station (Direction)
plt.figure(figsize=(18, 6))

plt.subplot(1, 3, 1)
mae_per_station_df_direction.plot(kind='bar', ax=plt.gca())
plt.title('MAE per Station (Direction)')

plt.subplot(1, 3, 2)
rmse_per_station_df_direction.plot(kind='bar', ax=plt.gca())
plt.title('RMSE per Station (Direction)')

plt.subplot(1, 3, 3)
corr_per_station_df_direction.plot(kind='bar', ax=plt.gca())
plt.title('Correlation per Station (Direction)')

plt.tight_layout()
plt.show()

# Summary of model performance metrics
metrics_speed = {
    'Model': ['icon_d2', 'icon_eu', 'era5'],
    'MAE': [
        np.mean([res['icon_d2'] for res in mae_per_station_speed]),
        np.mean([res['icon_eu'] for res in mae_per_station_speed]),
        np.mean([res['era5'] for res in mae_per_station_speed])
    ],
    'RMSE': [
        np.mean([res['icon_d2'] for res in rmse_per_station_speed]),
        np.mean([res['icon_eu'] for res in rmse_per_station_speed]),
        np.mean([res['era5'] for res in rmse_per_station_speed])
    ],
    'Correlation': [
        np.mean([res['icon_d2'] for res in corr_per_station_speed]),
        np.mean([res['icon_eu'] for res in corr_per_station_speed]),
        np.mean([res['era5'] for res in corr_per_station_speed])
    ]
}

metrics_direction = {
    'Model': ['icon_d2', 'icon_eu', 'era5'],
    'MAE': [
        np.mean([res['icon_d2'] for res in mae_per_station_direction]),
        np.mean([res['icon_eu'] for res in mae_per_station_direction]),
        np.mean([res['era5'] for res in mae_per_station_direction])
    ],
    'RMSE': [
        np.mean([res['icon_d2'] for res in rmse_per_station_direction]),
        np.mean([res['icon_eu'] for res in rmse_per_station_direction]),
        np.mean([res['era5'] for res in rmse_per_station_direction])
    ],
    'Correlation': [
        np.mean([res['icon_d2'] for res in corr_per_station_direction]),
        np.mean([res['icon_eu'] for res in corr_per_station_direction]),
        np.mean([res['era5'] for res in corr_per_station_direction])
    ]
}

metrics_df_speed = pd.DataFrame(metrics_speed)
metrics_df_direction = pd.DataFrame(metrics_direction)

print("\nSummary of Wind Speed Model Performance Metrics:\n", metrics_df_speed)
print("\nSummary of Wind Direction Model Performance Metrics:\n", metrics_df_direction)

# Plot heatmap for wind speed metrics
plt.figure(figsize=(10, 6))
sns.heatmap(metrics_df_speed.set_index('Model').T, annot=True, cmap='viridis')
plt.title('Model Performance Metrics for Wind Speed')
plt.show()

# Plot heatmap for wind direction metrics
plt.figure(figsize=(10, 6))
sns.heatmap(metrics_df_direction.set_index('Model').T, annot=True, cmap='viridis')
plt.title('Model Performance Metrics for Wind Direction')
plt.show()

"""You talked about time series forecasting :) Apply a model you have in mind to the dataset.
Which model is the best? Can you explain differences between stations?
"""

# Initialize lists to store predictions for plotting
y_pred_icon_d2 = []
y_pred_icon_eu = []
y_pred_era5 = []

# Iterate over each station
station_ids = np.unique(wind_data['station_id'].values) # Use np.unique() to find unique values in a NumPy array

for i, station_id in enumerate(station_ids): # Use enumerate to get index and value
    # Filter data for the current station
    station_data = wind_data.sel(station_id=station_id) # Use .sel to select data in xarray
    wind_speed = station_data['measured_wind_speed'].values
    wind_direction = station_data['measured_wind_direction'].values # Assuming this is your wind direction data
    time = station_data['time']

    # Prepare DataFrame for Prophet (for wind speed)
    df_speed = pd.DataFrame({
        'ds': time,
        'y': wind_speed
    })

    # Fit Prophet model for wind speed
    model_prophet_speed = Prophet()
    model_prophet_speed.fit(df_speed)
    future_speed = model_prophet_speed.make_future_dataframe(periods=100, freq='H')
    forecast_prophet_speed = model_prophet_speed.predict(future_speed)

    # Prepare DataFrame for Prophet (for wind direction)
    df_direction = pd.DataFrame({
        'ds': time,
        'y': wind_direction
    })

    # Fit Prophet model for wind direction
    model_prophet_direction = Prophet()
    model_prophet_direction.fit(df_direction)
    future_direction = model_prophet_direction.make_future_dataframe(periods=100, freq='H')
    forecast_prophet_direction = model_prophet_direction.predict(future_direction)

     # Store predicted values for plotting
    y_pred_icon_d2.append(station_data['icon_d2_wind_speed'].values)
    y_pred_icon_eu.append(station_data['icon_eu_wind_speed'].values)
    y_pred_era5.append(station_data['era5_wind_speed'].values)


    # Plot actual vs predicted wind speeds
    plt.figure(figsize=(12, 6))

    # Actual wind speed - Use index 'i' to access y_true
    plt.plot(time, wind_speed, label=f'Actual Wind Speed - Station {station_id}')

    # Predicted wind speeds - Use index 'i' to access predictions
    plt.plot(time, y_pred_icon_d2[i], label=f'Icon_d2 Predicted Wind Speed - Station {station_id}')
    plt.plot(time, y_pred_icon_eu[i], label=f'Icon_eu Predicted Wind Speed - Station {station_id}')
    plt.plot(time, y_pred_era5[i], label=f'Era5 Predicted Wind Speed - Station {station_id}')

    plt.xlabel('Time')
    plt.ylabel('Wind Speed')
    plt.legend()
    plt.title(f'Actual vs Predicted Wind Speeds - Station {station_id}')
    plt.show()

    # Plot forecasted wind speeds using Prophet
    plt.figure(figsize=(12, 6))
    plt.plot(df_speed['ds'], df_speed['y'], label='Actual Wind Speed')
    plt.plot(future_speed['ds'], forecast_prophet_speed['yhat'], label='Prophet Forecasted Wind Speed', linestyle='--')
    plt.xlabel('Time')
    plt.ylabel('Wind Speed')
    plt.legend()
    plt.title(f'Actual vs Prophet Forecasted Wind Speeds - Station {station_id}')
    plt.show()

    # Plot forecasted wind direction using Prophet
    plt.figure(figsize=(12, 6))
    plt.plot(df_direction['ds'], df_direction['y'], label='Actual Wind Direction')
    plt.plot(future_direction['ds'], forecast_prophet_direction['yhat'], label='Prophet Forecasted Wind Direction', linestyle='--')
    plt.xlabel('Time')
    plt.ylabel('Wind Direction')
    plt.legend()
    plt.title(f'Actual vs Prophet Forecasted Wind Directions - Station {station_id}')
    plt.show()

"""## model evaluvation"""

import xarray as xr
import numpy as np
import pandas as pd
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_absolute_percentage_error
from prophet import Prophet
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from statsmodels.tsa.arima.model import ARIMA
from sklearn.preprocessing import MinMaxScaler

# Load dataset
wind_data = xr.open_dataset("wind_2023.nc")



# Initialize lists to store predictions for EDA
y_true_speed_test = []
y_pred_speed_test_prophet = []
y_pred_speed_test_arima = []
y_pred_speed_test_lstm = []

# Function to impute NaNs with mean
def impute_with_mean(values):
    mean_value = np.nanmean(values)
    return np.nan_to_num(values, nan=mean_value)

# Function to flatten and align arrays
def flatten_and_align(y_true, y_pred):
    min_length = min(len(y_true), len(y_pred))
    return y_true[:min_length], y_pred[:min_length]

# Iterate over each station
station_ids = np.unique(wind_data['station_id'].values)

for station_id in station_ids:
    # Filter data for the current station
    station_data = wind_data.sel(station_id=station_id)
    wind_speed = station_data['measured_wind_speed'].values
    time = pd.to_datetime(station_data['time'].values)

    # Create DataFrame for wind speed
    df_speed = pd.DataFrame({
        'ds': time,
        'y': wind_speed
    })

    # Split the data into training (80%) and testing (20%) sets
    split_index = int(len(df_speed) * 0.8)
    train_speed = df_speed[:split_index]
    test_speed = df_speed[split_index:]

    # Prophet model
    model_prophet_speed = Prophet()
    model_prophet_speed.fit(train_speed)
    future_speed = model_prophet_speed.make_future_dataframe(periods=len(test_speed), freq='H')
    forecast_prophet_speed = model_prophet_speed.predict(future_speed)
    y_pred_speed_prophet = forecast_prophet_speed.set_index('ds')['yhat'].reindex(test_speed['ds']).values

    # ARIMA model
    model_arima_speed = ARIMA(train_speed['y'], order=(5, 1, 0))
    model_arima_speed_fit = model_arima_speed.fit()
    y_pred_speed_arima = model_arima_speed_fit.forecast(steps=len(test_speed))
    y_pred_speed_arima = np.array(y_pred_speed_arima)

    # LSTM model
    def create_lstm_dataset(X, time_step=1):
        Xs = []
        for i in range(len(X) - time_step):
            v = X[i:(i + time_step)]
            Xs.append(v)
        return np.array(Xs)

    time_step = 10
    train_speed_lstm = train_speed['y'].values
    test_speed_lstm = test_speed['y'].values
    train_speed_lstm = impute_with_mean(train_speed_lstm)
    test_speed_lstm = impute_with_mean(test_speed_lstm)

    train_speed_lstm_X = create_lstm_dataset(train_speed_lstm, time_step)
    test_speed_lstm_X = create_lstm_dataset(test_speed_lstm, time_step)

    train_speed_lstm_Y = train_speed_lstm[time_step:]
    test_speed_lstm_Y = test_speed_lstm[time_step:]

    model_lstm_speed = Sequential()
    model_lstm_speed.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))
    model_lstm_speed.add(LSTM(50, return_sequences=False))
    model_lstm_speed.add(Dense(25))
    model_lstm_speed.add(Dense(1))

    model_lstm_speed.compile(optimizer='adam', loss='mean_squared_error')
    model_lstm_speed.fit(train_speed_lstm_X, train_speed_lstm_Y, batch_size=1, epochs=1)

    y_pred_speed_lstm = model_lstm_speed.predict(test_speed_lstm_X)

    # Align and flatten arrays
    y_true_speed = test_speed.set_index('ds')['y'].values[time_step:]
    y_true_speed = impute_with_mean(y_true_speed)

    y_true_speed, y_pred_speed_prophet = flatten_and_align(y_true_speed, y_pred_speed_prophet[time_step:])
    y_true_speed, y_pred_speed_arima = flatten_and_align(y_true_speed, y_pred_speed_arima)
    y_true_speed, y_pred_speed_lstm = flatten_and_align(y_true_speed, y_pred_speed_lstm.flatten())

    y_true_speed_test.append(y_true_speed)
    y_pred_speed_test_prophet.append(y_pred_speed_prophet)
    y_pred_speed_test_arima.append(y_pred_speed_arima)
    y_pred_speed_test_lstm.append(y_pred_speed_lstm)

# Flatten lists for evaluation
y_true_speed_flat = np.concatenate(y_true_speed_test)
y_pred_speed_flat_prophet = np.concatenate(y_pred_speed_test_prophet)
y_pred_speed_flat_arima = np.concatenate(y_pred_speed_test_arima)
y_pred_speed_flat_lstm = np.concatenate(y_pred_speed_test_lstm)

# Calculate metrics for wind speed
mae_speed_prophet = mean_absolute_error(y_true_speed_flat, y_pred_speed_flat_prophet)
mse_speed_prophet = mean_squared_error(y_true_speed_flat, y_pred_speed_flat_prophet)
rmse_speed_prophet = np.sqrt(mse_speed_prophet)
mape_speed_prophet = mean_absolute_percentage_error(y_true_speed_flat, y_pred_speed_flat_prophet)

mae_speed_arima = mean_absolute_error(y_true_speed_flat, y_pred_speed_flat_arima)
mse_speed_arima = mean_squared_error(y_true_speed_flat, y_pred_speed_flat_arima)
rmse_speed_arima = np.sqrt(mse_speed_arima)
mape_speed_arima = mean_absolute_percentage_error(y_true_speed_flat, y_pred_speed_flat_arima)

mae_speed_lstm = mean_absolute_error(y_true_speed_flat, y_pred_speed_flat_lstm)
mse_speed_lstm = mean_squared_error(y_true_speed_flat, y_pred_speed_flat_lstm)
rmse_speed_lstm = np.sqrt(mse_speed_lstm)
mape_speed_lstm = mean_absolute_percentage_error(y_true_speed_flat, y_pred_speed_flat_lstm)

# Print metrics for each model
print('Prophet Model:')
print(f'Mean Absolute Error for Wind Speed: {mae_speed_prophet}')
print(f'Mean Squared Error for Wind Speed: {mse_speed_prophet}')
print(f'Root Mean Squared Error for Wind Speed: {rmse_speed_prophet}')
print(f'Mean Absolute Percentage Error for Wind Speed: {mape_speed_prophet}')

print('\nARIMA Model:')
print(f'Mean Absolute Error for Wind Speed: {mae_speed_arima}')
print(f'Mean Squared Error for Wind Speed: {mse_speed_arima}')
print(f'Root Mean Squared Error for Wind Speed: {rmse_speed_arima}')
print(f'Mean Absolute Percentage Error for Wind Speed: {mape_speed_arima}')

print('\nLSTM Model:')
print(f'Mean Absolute Error for Wind Speed: {mae_speed_lstm}')
print(f'Mean Squared Error for Wind Speed: {mse_speed_lstm}')
print(f'Root Mean Squared Error for Wind Speed: {rmse_speed_lstm}')
print(f'Mean Absolute Percentage Error for Wind Speed: {mape_speed_lstm}')

"""## wind direction"""

import xarray as xr
import numpy as np
import pandas as pd
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_absolute_percentage_error
from prophet import Prophet
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from statsmodels.tsa.arima.model import ARIMA

# Load dataset
wind_data = xr.open_dataset("wind_2023.nc")

# Initialize lists to store predictions for EDA
y_true_direction_test = []
y_pred_direction_test_prophet = []
y_pred_direction_test_arima = []
y_pred_direction_test_lstm = []

# Function to impute NaNs with mean
def impute_with_mean(values):
    mean_value = np.nanmean(values)
    return np.nan_to_num(values, nan=mean_value)

# Function to flatten and align arrays
def flatten_and_align(y_true, y_pred):
    min_length = min(len(y_true), len(y_pred))
    return y_true[:min_length], y_pred[:min_length]

# Iterate over each station
station_ids = np.unique(wind_data['station_id'].values)

for station_id in station_ids:
    # Filter data for the current station
    station_data = wind_data.sel(station_id=station_id)
    wind_direction = station_data['measured_wind_direction'].values
    time = pd.to_datetime(station_data['time'].values)

    # Create DataFrame for wind direction
    df_direction = pd.DataFrame({
        'ds': time,
        'y': wind_direction
    })

    # Split the data into training (80%) and testing (20%) sets
    split_index = int(len(df_direction) * 0.8)
    train_direction = df_direction[:split_index]
    test_direction = df_direction[split_index:]

    # Prophet model
    model_prophet_direction = Prophet()
    model_prophet_direction.fit(train_direction)
    future_direction = model_prophet_direction.make_future_dataframe(periods=len(test_direction), freq='H')
    forecast_prophet_direction = model_prophet_direction.predict(future_direction)
    y_pred_direction_prophet = forecast_prophet_direction.set_index('ds')['yhat'].reindex(test_direction['ds']).values

    # ARIMA model
    model_arima_direction = ARIMA(train_direction['y'], order=(5, 1, 0))
    model_arima_direction_fit = model_arima_direction.fit()
    y_pred_direction_arima = model_arima_direction_fit.forecast(steps=len(test_direction))
    y_pred_direction_arima = np.array(y_pred_direction_arima)

    # LSTM model
    def create_lstm_dataset(X, time_step=1):
        Xs = []
        for i in range(len(X) - time_step):
            v = X[i:(i + time_step)]
            Xs.append(v)
        return np.array(Xs)

    time_step = 10
    train_direction_lstm = train_direction['y'].values
    test_direction_lstm = test_direction['y'].values
    train_direction_lstm = impute_with_mean(train_direction_lstm)
    test_direction_lstm = impute_with_mean(test_direction_lstm)

    train_direction_lstm_X = create_lstm_dataset(train_direction_lstm, time_step)
    test_direction_lstm_X = create_lstm_dataset(test_direction_lstm, time_step)

    train_direction_lstm_Y = train_direction_lstm[time_step:]
    test_direction_lstm_Y = test_direction_lstm[time_step:]

    model_lstm_direction = Sequential()
    model_lstm_direction.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))
    model_lstm_direction.add(LSTM(50, return_sequences=False))
    model_lstm_direction.add(Dense(25))
    model_lstm_direction.add(Dense(1))

    model_lstm_direction.compile(optimizer='adam', loss='mean_squared_error')
    model_lstm_direction.fit(train_direction_lstm_X, train_direction_lstm_Y, batch_size=1, epochs=1)

    y_pred_direction_lstm = model_lstm_direction.predict(test_direction_lstm_X)

    # Align and flatten arrays
    y_true_direction = test_direction.set_index('ds')['y'].values[time_step:]
    y_true_direction = impute_with_mean(y_true_direction)

    y_true_direction, y_pred_direction_prophet = flatten_and_align(y_true_direction, y_pred_direction_prophet[time_step:])
    y_true_direction, y_pred_direction_arima = flatten_and_align(y_true_direction, y_pred_direction_arima)
    y_true_direction, y_pred_direction_lstm = flatten_and_align(y_true_direction, y_pred_direction_lstm.flatten())

    y_true_direction_test.append(y_true_direction)
    y_pred_direction_test_prophet.append(y_pred_direction_prophet)
    y_pred_direction_test_arima.append(y_pred_direction_arima)
    y_pred_direction_test_lstm.append(y_pred_direction_lstm)

# Flatten lists for evaluation
y_true_direction_flat = np.concatenate(y_true_direction_test)
y_pred_direction_flat_prophet = np.concatenate(y_pred_direction_test_prophet)
y_pred_direction_flat_arima = np.concatenate(y_pred_direction_test_arima)
y_pred_direction_flat_lstm = np.concatenate(y_pred_direction_test_lstm)

# Calculate metrics for wind direction
mae_direction_prophet = mean_absolute_error(y_true_direction_flat, y_pred_direction_flat_prophet)
mse_direction_prophet = mean_squared_error(y_true_direction_flat, y_pred_direction_flat_prophet)
rmse_direction_prophet = np.sqrt(mse_direction_prophet)
mape_direction_prophet = mean_absolute_percentage_error(y_true_direction_flat, y_pred_direction_flat_prophet)

mae_direction_arima = mean_absolute_error(y_true_direction_flat, y_pred_direction_flat_arima)
mse_direction_arima = mean_squared_error(y_true_direction_flat, y_pred_direction_flat_arima)
rmse_direction_arima = np.sqrt(mse_direction_arima)
mape_direction_arima = mean_absolute_percentage_error(y_true_direction_flat, y_pred_direction_flat_arima)

mae_direction_lstm = mean_absolute_error(y_true_direction_flat, y_pred_direction_flat_lstm)
mse_direction_lstm = mean_squared_error(y_true_direction_flat, y_pred_direction_flat_lstm)
rmse_direction_lstm = np.sqrt(mse_direction_lstm)
mape_direction_lstm = mean_absolute_percentage_error(y_true_direction_flat, y_pred_direction_flat_lstm)

# Print metrics for each model
print('Prophet Model:')
print(f'Mean Absolute Error for Wind Direction: {mae_direction_prophet}')
print(f'Mean Squared Error for Wind Direction: {mse_direction_prophet}')
print(f'Root Mean Squared Error for Wind Direction: {rmse_direction_prophet}')
print(f'Mean Absolute Percentage Error for Wind Direction: {mape_direction_prophet}')

print('\nARIMA Model:')
print(f'Mean Absolute Error for Wind Direction: {mae_direction_arima}')
print(f'Mean Squared Error for Wind Direction: {mse_direction_arima}')
print(f'Root Mean Squared Error for Wind Direction: {rmse_direction_arima}')
print(f'Mean Absolute Percentage Error for Wind Direction: {mape_direction_arima}')

print('\nLSTM Model:')
print(f'Mean Absolute Error for Wind Direction: {mae_direction_lstm}')
print(f'Mean Squared Error for Wind Direction: {mse_direction_lstm}')
print(f'Root Mean Squared Error for Wind Direction: {rmse_direction_lstm}')
print(f'Mean Absolute Percentage Error for Wind Direction: {mape_direction_lstm}')

import matplotlib.pyplot as plt

def plot_forecast_vs_actual(y_true, y_pred, model_name):
    plt.figure(figsize=(14, 7))
    plt.plot(y_true, label='Actual Values')
    plt.plot(y_pred, label='Predicted Values')
    plt.title(f'Forecast vs Actuals for {model_name} Model')
    plt.xlabel('Time')
    plt.ylabel('Wind Speed')
    plt.legend()
    plt.show()

# Plot for Prophet model
plot_forecast_vs_actual(y_true_speed_flat, y_pred_speed_flat_prophet, 'Prophet')

# Plot for ARIMA model
plot_forecast_vs_actual(y_true_speed_flat, y_pred_speed_flat_arima, 'ARIMA')

# Plot for LSTM model
plot_forecast_vs_actual(y_true_speed_flat, y_pred_speed_flat_lstm, 'LSTM')

import xarray as xr
import numpy as np
import pandas as pd
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_absolute_percentage_error
from prophet import Prophet
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from statsmodels.tsa.arima.model import ARIMA

# Load dataset
wind_data = xr.open_dataset("wind_2023.nc")

# Initialize lists to store predictions for EDA
y_true_direction_test = []
y_pred_direction_test_prophet = []
y_pred_direction_test_arima = []
y_pred_direction_test_lstm = []

# Function to impute NaNs with mean
def impute_with_mean(values):
    mean_value = np.nanmean(values)
    return np.nan_to_num(values, nan=mean_value)

# Function to flatten and align arrays
def flatten_and_align(y_true, y_pred):
    min_length = min(len(y_true), len(y_pred))
    return y_true[:min_length], y_pred[:min_length]

# Iterate over each station
station_ids = np.unique(wind_data['station_id'].values)

for station_id in station_ids:
    # Filter data for the current station
    station_data = wind_data.sel(station_id=station_id)
    wind_direction = station_data['measured_wind_direction'].values
    time = pd.to_datetime(station_data['time'].values)

    # Create DataFrame for wind direction
    df_direction = pd.DataFrame({
        'ds': time,
        'y': wind_direction
    })

    # Split the data into training (80%) and testing (20%) sets
    split_index = int(len(df_direction) * 0.8)
    train_direction = df_direction[:split_index]
    test_direction = df_direction[split_index:]

    # Prophet model
    model_prophet_direction = Prophet()
    model_prophet_direction.fit(train_direction)
    future_direction = model_prophet_direction.make_future_dataframe(periods=len(test_direction), freq='H')
    forecast_prophet_direction = model_prophet_direction.predict(future_direction)
    y_pred_direction_prophet = forecast_prophet_direction.set_index('ds')['yhat'].reindex(test_direction['ds']).values

    # ARIMA model
    model_arima_direction = ARIMA(train_direction['y'], order=(5, 1, 0))
    model_arima_direction_fit = model_arima_direction.fit()
    y_pred_direction_arima = model_arima_direction_fit.forecast(steps=len(test_direction))
    y_pred_direction_arima = np.array(y_pred_direction_arima)

    # LSTM model
    def create_lstm_dataset(X, time_step=1):
        Xs = []
        for i in range(len(X) - time_step):
            v = X[i:(i + time_step)]
            Xs.append(v)
        return np.array(Xs)

    time_step = 10
    train_direction_lstm = train_direction['y'].values
    test_direction_lstm = test_direction['y'].values
    train_direction_lstm = impute_with_mean(train_direction_lstm)
    test_direction_lstm = impute_with_mean(test_direction_lstm)

    train_direction_lstm_X = create_lstm_dataset(train_direction_lstm, time_step)
    test_direction_lstm_X = create_lstm_dataset(test_direction_lstm, time_step)

    train_direction_lstm_Y = train_direction_lstm[time_step:]
    test_direction_lstm_Y = test_direction_lstm[time_step:]

    model_lstm_direction = Sequential()
    model_lstm_direction.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))
    model_lstm_direction.add(LSTM(50, return_sequences=False))
    model_lstm_direction.add(Dense(25))
    model_lstm_direction.add(Dense(1))

    model_lstm_direction.compile(optimizer='adam', loss='mean_squared_error')
    model_lstm_direction.fit(train_direction_lstm_X, train_direction_lstm_Y, batch_size=1, epochs=1)

    y_pred_direction_lstm = model_lstm_direction.predict(test_direction_lstm_X)

    # Align and flatten arrays
    y_true_direction = test_direction.set_index('ds')['y'].values[time_step:]
    y_true_direction = impute_with_mean(y_true_direction)

    y_true_direction, y_pred_direction_prophet = flatten_and_align(y_true_direction, y_pred_direction_prophet[time_step:])
    y_true_direction, y_pred_direction_arima = flatten_and_align(y_true_direction, y_pred_direction_arima)
    y_true_direction, y_pred_direction_lstm = flatten_and_align(y_true_direction, y_pred_direction_lstm.flatten())

    y_true_direction_test.append(y_true_direction)
    y_pred_direction_test_prophet.append(y_pred_direction_prophet)
    y_pred_direction_test_arima.append(y_pred_direction_arima)
    y_pred_direction_test_lstm.append(y_pred_direction_lstm)

# Flatten lists for evaluation
if y_true_direction_test and y_pred_direction_test_prophet and y_pred_direction_test_arima and y_pred_direction_test_lstm:
    y_true_direction_flat = np.concatenate(y_true_direction_test)
    y_pred_direction_flat_prophet = np.concatenate(y_pred_direction_test_prophet)
    y_pred_direction_flat_arima = np.concatenate(y_pred_direction_test_arima)
    y_pred_direction_flat_lstm = np.concatenate(y_pred_direction_test_lstm)

    # Plot for Prophet model
    plot_forecast_vs_actual(y_true_direction_flat, y_pred_direction_flat_prophet, 'Prophet')

    # Plot for ARIMA model
    plot_forecast_vs_actual(y_true_direction_flat, y_pred_direction_flat_arima, 'ARIMA')

    # Plot for LSTM model
    plot_forecast_vs_actual(y_true_direction_flat, y_pred_direction_flat_lstm, 'LSTM')

else:
    print("One or more lists are empty. Ensure predictions are collected correctly.")